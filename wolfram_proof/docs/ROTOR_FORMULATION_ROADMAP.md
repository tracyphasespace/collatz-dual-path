# Rotor Formulation Roadmap

**Date:** 2026-01-16
**Status:** New investigation path following diagonal operator refutation

---

## Background: Why Rotors?

The diagonal operator K(s) = diag(Λ(n)·n^{-s}) failed because:
1. It always has non-trivial kernel (Λ(n) = 0 for non-prime-powers)
2. The Rayleigh identity does not hold
3. Kernel existence is independent of ζ(s) = 0

Wolfram proposed: **Replace the static kernel test with dynamic rotor phase-locking.**

---

## Core Concept: Rotor-Based Operator

### Definition

For each prime p, define a rotor:
```
R_p(s) := Rotor generated by log(p), acting in Cl(3,3)
```

The full sieve operator is the product:
```
R(s) := ∏_{p ≤ N} R_p(s)
```

Each rotor acts as a **frequency twist** in a distinct eigenspace.

### Zero Condition as Phase Lock

At a zeta zero, the twisted system returns to identity:
```
R(s)v = v
```

The total rotor product becomes **unitary** - all prime-induced rotors align constructively.

### Critical Line as Stability

- σ < 1/2: rotors diverge
- σ > 1/2: rotors over-converge
- σ = 1/2: total rotor is unitary (stable)

This is the physical meaning of RH in the rotor framework.

---

## New Definition: Rotor Zeta Function

```
Z_rotor(s) := ⟨v, R(s)v⟩
```

Zeros represent **resonance alignment** in the Clifford-rotor manifold.

**Hypothesis:** This may be better aligned to RH than scalar ζ(s).

---

## Implementation Roadmap

### Phase 1: Define R_p(s) in Wolfram

```mathematica
(* Single prime rotor *)
PrimeRotor[p_, s_] := Module[{theta, B},
  theta = Log[p] * Im[s];
  B = (* bivector in Cl(3,3) *);
  MatrixExp[theta * B]
]

(* Total rotor product *)
TotalRotor[s_, maxP_] := Product[PrimeRotor[p, s], {p, Prime[Range[PrimePi[maxP]]]}]
```

### Phase 2: Numerical Tests

| Test | Description | Expected |
|------|-------------|----------|
| Phase at zeros | Compute R(1/2 + i·γ) at known zeros | Should approach identity |
| Off-critical | Compute R(σ + i·γ) for σ ≠ 1/2 | Should diverge from identity |
| Rotor zeta | Plot Z_rotor(s) along critical line | Zeros should match ζ(s) zeros |

### Phase 3: Lean Formalization

Create `RotorFredholmOperator.lean`:
- Define rotor in Cl(3,3)
- Define product over primes
- State unitarity condition
- Connect to RH

### Phase 4: Equivalence Proof

**Required to prove RH:**
```
R(s)v = v ⟺ ζ(s) = 0
```

Or at minimum:
```
ζ(s) = 0 ⟹ R(s)v = v for some v ≠ 0
R(s)v = v ⟹ σ = 1/2
```

---

## Key Questions to Resolve

1. **What is the bivector B in Cl(3,3)?**
   - Must encode prime geometry
   - Should give distinct rotation planes for different primes

2. **How does R(s) relate to ζ(s)?**
   - Need explicit connection formula
   - Possibly through trace or determinant

3. **Why does σ = 1/2 give unitarity?**
   - Need rigorous argument, not just intuition
   - May involve spectral theory

4. **Can we prove spectral rigidity?**
   - Only critical line allows phase cancellation
   - Variational or Rayleigh quotient argument?

---

## Files to Create

| File | Purpose |
|------|---------|
| `notebooks/05_rotor_operators.wl` | Wolfram implementation of R_p(s) |
| `notebooks/06_rotor_visualization.wl` | Vector field visualization |
| `notebooks/07_rotor_zeta_comparison.wl` | Compare Z_rotor zeros to ζ zeros |
| `lean/RotorFredholmOperator.lean` | Lean formalization |

---

## Success Criteria

The rotor formulation succeeds if we can show:

1. **Numerical:** R(s) approaches identity at known zeta zeros
2. **Off-critical:** R(s) diverges for σ ≠ 1/2
3. **Theoretical:** Explicit formula connecting R(s) eigenvalue 1 to ζ(s) = 0
4. **Formal:** Lean proof that unitarity implies σ = 1/2

---

## Next Steps

1. Implement PrimeRotor[p, s] in Wolfram
2. Test at γ₁ = 14.1347 (first zeta zero)
3. Visualize rotor flow as vector field
4. If numerical tests pass, proceed to Lean formalization

---

*This roadmap replaces the failed diagonal operator approach with a dynamic kinematic model.*
